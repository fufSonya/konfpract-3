# Результат работы (вариант 8):

Ассемблер (этапы 1–2). Спроектирован CSV-язык (поддержка LOAD_CONST/READ_MEM/WRITE_MEM/NOT_MEM), реализован парсер и вывод IR в формате задания, добавлен конвертер в 14-байтовые слова. CLI main.py умеет собирать программы и в тестовом режиме печатать поля и байты; examples/spec_tests.csv даёт последовательность, совпадающую со спецификацией.

Интерпретатор и память (этап 3–4). Введена разрежённая 64-битная память, цикл исполнения команд, XML-дампы адресных диапазонов, поддержана побитовая операция NOT. Написаны и прогнаны программы copy_array (копирование массива) и not_store (NOT со сохранением в отдельные ячейки), их бинарники и дампы размещены в examples/.

Тестовая задача (этап 5). Реализована программа not_vector_inplace, выполняющая побитовое «не» над вектором из восьми значений с записью в исходный массив (через временный буфер). Дамп показывает корректные инверсии. В README задокументированы все команды запуска и ссылки на файлы.

## Язык ассемблера (CSV)

Каждый файл описывает программу в формате CSV со следующими правилами:

- Первая строка — заголовок с колонкой `opcode` (регистр не важен). Остальные
  колонки — именованные поля (`B`, `C`, `D`).
- Пустые строки и строки, начинающиеся с `#`, игнорируются.
- Значения полей задаются десятичными, либо в Python-совместимом формате
  (`0xFF`, `0b1010`).
- Ненужные для инструкции поля оставляются пустыми.

Пример (`examples/not_vector_inplace.csv`):

```
opcode,B,C,D
# Pointer to vector base
LOAD_CONST,4000,40,
# Vector data (8 элементов)
LOAD_CONST,170,4000,
...
NOT_MEM,40,0,5000
WRITE_MEM,5000,4000,
```

### Поддерживаемые инструкции

| Mnemonic    | A | Поля                    | Описание |
|-------------|---|------------------------|----------|
| `LOAD_CONST`|17 | `B` (17 бит) `C` (29 бит)| Записывает константу `B` по адресу `C`.
| `READ_MEM`  |16 | `B` (29) `C` (15) `D` (29)| Суммирует базовый адрес `mem[B]` и смещение `C`, читает по полученному адресу и кладёт результат по адресу `D`.
| `WRITE_MEM` |23 | `B` (29) `C` (29)        | Копирует значение из `mem[B]` в `mem[C]`.
| `NOT_MEM`   |24 | `B` (29) `C` (15) `D` (29)| Читает `mem[mem[B] + C]`, инвертирует побитово (по модулю 2^64) и сохраняет в `mem[D]`.


Команды сборки/запуска для копирования массива:

```
python3 main.py assemble --input examples/copy_array.csv --output examples/copy_array.bin
python3 main.py interpret --binary examples/copy_array.bin \
  --dump examples/copy_array_dump.xml --range 0 2050
```

Полученный дамп фиксирует, что значения по `2000-2007` совпадают с источником
`1000-1007`.

Аналогично для `not_store` и `not_vector_inplace` дампы показывают корректные
инверсии чисел (по модулю `2^64`).

## Команды сборки/запуска для копирования массива:

python3 main.py assemble --input examples/copy_array.csv --output examples/copy_array.bin
python3 main.py interpret --binary examples/copy_array.bin \
  --dump examples/copy_array_dump.xml --range 0 2050

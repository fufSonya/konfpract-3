# Учебная виртуальная машина (УВМ)

CLI-набор "GPT-5.1 Codex UVM" включает ассемблер и интерпретатор для учебной
виртуальной машины из варианта №8. Инструменты позволяют переводить текстовые
CSV-программы в машинный код, исполнять собранные бинарники и сохранять дампы
памяти в формате XML.

## Требования

- Python 3.10+
- Запуск из корня репозитория: `python3 main.py ...`

## Язык ассемблера (CSV)

Каждый файл описывает программу в формате CSV со следующими правилами:

- Первая строка — заголовок с колонкой `opcode` (регистр не важен). Остальные
  колонки — именованные поля (`B`, `C`, `D`).
- Пустые строки и строки, начинающиеся с `#`, игнорируются.
- Значения полей задаются десятичными, либо в Python-совместимом формате
  (`0xFF`, `0b1010`).
- Ненужные для инструкции поля оставляются пустыми.

Пример (`examples/not_vector_inplace.csv`):

```
opcode,B,C,D
# Pointer to vector base
LOAD_CONST,4000,40,
# Vector data (8 элементов)
LOAD_CONST,170,4000,
...
NOT_MEM,40,0,5000
WRITE_MEM,5000,4000,
```

### Поддерживаемые инструкции

| Mnemonic    | A | Поля                    | Описание |
|-------------|---|------------------------|----------|
| `LOAD_CONST`|17 | `B` (17 бит) `C` (29 бит)| Записывает константу `B` по адресу `C`.
| `READ_MEM`  |16 | `B` (29) `C` (15) `D` (29)| Суммирует базовый адрес `mem[B]` и смещение `C`, читает по полученному адресу и кладёт результат по адресу `D`.
| `WRITE_MEM` |23 | `B` (29) `C` (29)        | Копирует значение из `mem[B]` в `mem[C]`.
| `NOT_MEM`   |24 | `B` (29) `C` (15) `D` (29)| Читает `mem[mem[B] + C]`, инвертирует побитово (по модулю 2^64) и сохраняет в `mem[D]`.

## Ассемблер

```
python3 main.py assemble --input examples/spec_tests.csv \
  --output examples/spec_tests.bin [--test]
```

- `--test` печатает промежуточное представление (`A=..., B=...`) и дамп собранных
  байт, как в спецификации.
- После сборки сообщается количество команд, файл содержит последовательность
  14-байтовых слов в little-endian.

## Интерпретатор

```
python3 main.py interpret --binary build/program.bin --dump out/memory.xml --range 0 4096 [--max-steps N]
```

- Аргументы соответствуют требованиям этапа 3: путь к бинарнику, путь для
  XML-дампа и диапазон адресов памяти (включительно).
- Опционально можно ограничить число шагов `--max-steps`.
- Память реализована как разрежённое словарь-хранилище 64-битных слов (общая
  модель для команд и данных). Неинициализированные ячейки читаются как `0`.

### Формат дампа

Файл представляет собой XML вида:

```
<memory start="0" end="16">
  <cell address="0" value="0" />
  <cell address="10" value="1000" />
</memory>
```

## Примерные программы

| Файл | Назначение | Бинарник | Дамп |
|------|------------|----------|------|
| `examples/spec_tests.csv` | Прямые тесты из спецификации (этапы 1–2, режим `--test`) | `examples/spec_tests.bin` | — |
| `examples/copy_array.csv` | Копирование массива из адресов `1000-1007` в `2000-2007` (этап 3) | `examples/copy_array.bin` | `examples/copy_array_dump.xml` |
| `examples/not_store.csv` | Проверка операции побитового НЕ с сохранением результатов (этап 4) | `examples/not_store.bin` | `examples/not_store_dump.xml` |
| `examples/not_vector_inplace.csv` | Побитовое НЕ над вектором длины 8 с сохранением в исходный массив (этап 5) | `examples/not_vector_inplace.bin` | `examples/not_vector_inplace_dump.xml` |

Команды сборки/запуска для копирования массива:

```
python3 main.py assemble --input examples/copy_array.csv --output examples/copy_array.bin
python3 main.py interpret --binary examples/copy_array.bin \
  --dump examples/copy_array_dump.xml --range 0 2050
```

Полученный дамп фиксирует, что значения по `2000-2007` совпадают с источником
`1000-1007`.

Аналогично для `not_store` и `not_vector_inplace` дампы показывают корректные
инверсии чисел (по модулю `2^64`).

## Дополнительные заметки

- Все инструкции исполняются последовательно; условные переходы спецификацией
  не предусмотрены, поэтому примеры с циклами развёрнуты вручную.
- Значения, записываемые в память, автоматически маскируются до 64 бит.
- В тестовом режиме ассемблер полностью повторяет формат таблиц из задания,
  что позволяет сравнивать поля с эталонными значениями из варианта.
